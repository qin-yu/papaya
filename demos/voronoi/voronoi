#!/usr/bin/env python
# voronoi  -- reads a point pattern from a .xyz file,
# calculates the Voronoi tesselation (using appropriate BC)
# and calculates the Minkowski Tensors.
import os
import sys
import xyz
import bc
import tempfile
import qhulldriver
from shared import die, break_line_into_string

# read .xyz data
infile = sys.argv[1]
(germs,comment) = xyz.read_xyz_with_comment (infile)
num_original_points = len (germs)
voronoi_dump_file = None
bounds_override = None

# do we want a dump of the Voronoi data?
if '--dump' in sys.argv:
    z = sys.argv.index ('--dump') + 1
    voronoi_dump_file = sys.argv[z]

# override bounds?
if '--bounds' in sys.argv:
    z = sys.argv.index ('--bounds') + 1
    bounds_override = sys.argv[z]

germs = [ (p[1],p[2]) for p in germs ]

# we include some parameters of the dataset in the xyz comment
data_from_comment = xyz.split_comment (comment)

analyze = [] # says whether we'll run the cell generated by
             # this germ through Papaya.

bounds = data_from_comment['boundary_condition']
if bounds_override:
    bounds = bounds_override

# treat boundary conditions
if bounds == 'periodic_rectangular' or bounds == 'periodic_rectangular_4p':
    sizex = None
    sizey = None
    if bounds == 'periodic_rectangular_4p':
        # Walter's format
        xhi = float (data_from_comment['boxsz_xhi'])
        yhi = float (data_from_comment['boxsz_yhi'])
        xlo = float (data_from_comment['boxsz_xlo'])
        ylo = float (data_from_comment['boxsz_ylo'])
        sizex = xhi-xlo
        sizey = yhi-ylo
    else:
        sizex = float (data_from_comment['boxsz_x'])
        sizey = float (data_from_comment['boxsz_y'])
    germs.extend (bc.add_periodic_copies (germs,
        (sizex,sizey),
        [(sizex,0.), (0.,sizey), (sizex,sizey),
         (-sizex,0.), (0.,-sizey), (sizex,-sizey), (-sizex,sizey), (-sizex,-sizey)],
        overlap_factor = .2))
    # new points only are appended; we're interested in the
    # first $num_original_points germs in the list.
    analyze = [True] * num_original_points
    analyze.append ([False] * (len (germs) - num_original_points))

elif bounds == 'periodic_hexagonal':
    # "hexagonal" bc -- we expect a rectangle here, but with particular
    # boundary conditions. this equivalent to real hexagons tiling the plane.
    sizex = float (data_from_comment['boxsz_x'])
    sizey = float (data_from_comment['boxsz_y'])
    germs.extend (bc.add_periodic_copies (germs,
        (sizex,sizey),
        [(sizex,.5*sizey), (0.,sizey), (sizex,-.5*sizey),
         (-sizex,.5*sizey), (0.,-sizey), (-sizex,-.5*sizey)],
        overlap_factor = .2))
    # new points only are appended; we're interested in the
    # first $num_original_points germs in the list.
    analyze = [True] * num_original_points
    analyze.append ([False] * (len (germs) - num_original_points))

elif bounds == 'minus_sample_rectangular':
    # ignore the outer 10% of the data
    # no periodic padding is done.
    sizex = float (data_from_comment['boxsz_x'])
    sizey = float (data_from_comment['boxsz_y'])
    analyze = [True] * num_original_points
    num_dropped_points = 0
    for i in range (num_original_points):
        if abs (germs[i][0] - .5*sizex) > .4*sizex or \
                abs (germs[i][1] - .5*sizey) > .4*sizey:
            analyze[i] = False
            num_dropped_points += 1
    print >>sys.stderr, '[%s] dropping %i of the %i germs' %\
        ('minus_sample_rectangular', num_dropped_points, num_original_points)

else:
    die ('Not implemented')

# we could compute a generalized Voronoi diagram here
# (we don't)
df = 1

# compute Voronoi diagram; 
voro = qhulldriver.qvoronoi (germs)

assert len (germs) == len (voro.polys)

# delete cells induced by padding germs
voro.polys = voro.polys[0:df*num_original_points]

# delete cells induced by non-selected germs
assert len (voro.polys) == df * num_original_points
for i in range (num_original_points-1,-1,-1):
    for j in range (df):
        if analyze[i]:
            assert voro.point_in_poly (germs[i],i*df+j)
            voro.polys[i*df+j][0] = i
        else:
            del voro.polys[i*df+j]

# we would re-merge the cells of the generalized Voronoi here
# (again, we don't)

# we should have no references to the 'vertex at infinity' left
for i in range (len (voro.polys)):
    assert not (1 in voro.polys[i][1:])

voro.reindex ()

if voronoi_dump_file:
    voro.save_poly (voronoi_dump_file)

# move every cell to the origin
def subtr (c1, c2):
    assert len (c1) == len (c2)
    if len (c1) == 2:
        return (c1[0]-c2[0], c1[1]-c2[1])
    else:
        return (c1[0]-c2[0], c1[1]-c2[1], c1[2]-c2[2])

for i in range (len (voro.polys)):
    s = germs[voro.polys[i][0]]
    for j in voro.polys[i][1:]:
        voro.coords[j] = subtr (voro.coords[j], s)
        voro.coords[j] = (voro.coords[j][0], voro.coords[j][1], i)

# compute MT
poly_fn = qhulldriver.get_temp_file_name (suffix = ".poly")  # papaya is a little picky about suffixes
voro.save_poly (poly_fn)
outdir = infile + "_mink_val"
if os.system ('mkdir %s; papaya -c %s.conf -i "%s" -o "%s/"' % (outdir, sys.argv[0], poly_fn, outdir)) != 0:
    die ("papaya failed (not found?)")
#os.remove (poly_fn)

sys.exit (0)
